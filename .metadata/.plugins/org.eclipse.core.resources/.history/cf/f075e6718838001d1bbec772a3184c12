/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
#include "defines_pines.h"
#include "delay.h"

uint16_t adcRead;
uint16_t adc_read[2]; //variable para modo scan 3 canales


//Pines Analogicos:
#define ADC1_IN0	A,0
#define ADC1_IN1	A,1
#define ADC1_IN4	A,4
#define ADC1_IN8	B,0
#define ADC1_IN10	C,0
#define ADC1_IN11	C,1

#define ADC_CH0		0
#define ADC_CH1		1
#define ADC_CH2		2
#define ADC_CH3		3
#define ADC_CH4		4
#define ADC_CH5		5
#define ADC_CH6		6
#define ADC_CH7		7
#define ADC_CH8		8
#define ADC_CH9		9
#define ADC_CH10	10
#define ADC_CH11	11
#define ADC_CH12	12
#define ADC_CH13	13
#define ADC_CH14	14
#define ADC_CH15	15


void ADC_SingleModeInit(void);
uint16_t ADC_ReadSingleMode(uint8_t channel);

void ADC_ScanModeInit(void);
void ADC_ReadScanMode(void);

int main(void)
{
	delay_init();

	//ADC_ScanModeInit();
	ADC_SingleModeInit();

	for(;;){

		adcRead = ADC_ReadSingleMode(ADC_CH0); //leer el adc canal 0
		delay_ms(100);
	}
}

void ADC_ScanModeInit(void){
	//Habilitar reloj del periferico conectado al bus APB2
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;

	//Configuracion del periferico:
	ADC1_COMMON->CCR &=~ADC_CCR_ADCPRE; //prescaler PLCK2/2 -> 16Mhz/2 = 8Mhz
	ADC1->CR1 = 0; //limpiar registro de control 1
	ADC1->CR2 = 0; //limpiar registro de control 2

	//Configurar modo de trabajo: (auto, scan, single, etc...)
	ADC1->CR1 |= ADC_CR1_SCAN; //adc modo scan (multiples canales)

	ADC1->CR2 |= ADC_CR2_EOCS; //interrupcion cada vez que termine cada convesion regular

	//Configurar la secuencia de las conversiones (modo scan)
	//numero de conversiones se desea:
	ADC1->SQR3 = (3-1)<<20; //realizar 3 conversiones

	//orden de conversiones:
	ADC1->SQR3 |= 0<<10 | 1<<15 | 4<<0; //CH4->CH1->CH0

	//sampling (frecuencia de muestreo)
	ADC1->SMPR2 = 0x3U;  //56 ciclos de reloj
	ADC1->SMPR2 |= 0x5U<<12; //112 ciclos de reloj

	//habilitar el ADC:
	ADC1->CR2 |= ADC_CR2_ADON; //enable ADC

	/*
	 * Configuracion de canales del ADC modo Scan
	*/

	RCC->AHB1ENR |= GPIOX_CLOCK(ADC1_IN0) | GPIOX_CLOCK(ADC1_IN1) | GPIOX_CLOCK(ADC1_IN4); //habilitar reloj para los canales ADC

	//configurar canales (pines):

	//funcion Analogica de cada pin:
	GPIOX_MODER(MODE_ANALOG_INPUT, ADC1_IN0);
	GPIOX_MODER(MODE_ANALOG_INPUT, ADC1_IN1);
	GPIOX_MODER(MODE_ANALOG_INPUT, ADC1_IN4);

	//Deshabilitar pull up/pull down:
	GPIOX_PUPDR(MODE_PU_NONE, ADC1_IN0);
	GPIOX_PUPDR(MODE_PU_NONE, ADC1_IN1);
	GPIOX_PUPDR(MODE_PU_NONE, ADC1_IN4);

	return;

}

void ADC_ReadScanMode(void){

	ADC1->CR2 |= ADC_CR2_SWSTART; //adc -> disparo por software (software trigger)

	//polling (cambia automaticamente de canal ya que esta en modo scan)
	while(!(ADC1->SR & ADC_SR_EOC)); //esperar a que termine la conversion
	adc_read[0]=ADC1->DR;    //leer el valor del canal

	while(!(ADC1->SR & ADC_SR_EOC)); //esperar a que termine la conversion
	adc_read[1]=ADC1->DR;    //leer el valor del canal

	while(!(ADC1->SR & ADC_SR_EOC)); //esperar a que termine la conversion
	adc_read[2]=ADC1->DR;    //leer el valor del canal
	delay_ms(100);
}

void ADC_SingleModeInit(void){ //configuracion para el canal 1:


	//habilitar el reloj:
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;

	//configurar parametros del adc:
	ADC1_COMMON->CCR &=~ADC_CCR_ADCPRE; //	PLCK2/2 = 16Mhz/2 = 8Mhz

	ADC1->CR1 = 0; //limpiar registro de control 1
	ADC1->CR2 = 0; //limpiar registro de control 2

	//habilitar ADC
	ADC1->CR2 |= ADC_CR2_ADON; //encender ADC


	/*********Habilitar canales*****************/
	GPIO_CLOCK_ENABLE(A); //habilitar reloj para el puerto A

	//configurar canales:
	//funcion Analogica de cada pin:
	GPIOX_MODER(MODE_ANALOG_INPUT, ADC1_IN0);
	GPIOX_MODER(MODE_ANALOG_INPUT, ADC1_IN1);
	GPIOX_MODER(MODE_ANALOG_INPUT, ADC1_IN4);

	//Deshabilitar pull up/pull down:
	GPIOX_PUPDR(MODE_PU_NONE, ADC1_IN0);
	GPIOX_PUPDR(MODE_PU_NONE, ADC1_IN1);
	GPIOX_PUPDR(MODE_PU_NONE, ADC1_IN4);

	//tiempo de muestreo:
	ADC1->SMPR2 |= ADC_SMPR2_SMP4_1; //28 ciclos de muestreo

	return;

}

uint16_t ADC_ReadSingleMode(uint8_t channel){
	ADC1->SQR1 &=~ADC_SQR1_L; //una sola conversion por disparo (single mode)
	ADC1->SQR3 &=~ADC_SQR3_SQ1;
	ADC1->SQR3 |= channel; //canal a convertir
	 //trigger (fuente de disparo)
	ADC1->CR2 |= ADC_CR2_SWSTART; //fuente de disparo por software, inicia la conversion
	while(!(ADC1->SR & ADC_SR_EOC)); //esperar a que la conversion termine

	return ADC1->DR; //retornar el valor convertido
}



