/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>

#define USART2_TX	A,2
#define USART2_RX	A,3

/*
 * @brief configura el USART2 a 115200
 */
void USART2_Init(void);

void USART2_GPIO_Init(void);


int main(void)
{
    /* Loop forever */
	USART2_GPIO_Init();
	USART2_Init();
	for(;;);
}

void USART2_Init(void){
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN; //habilitar el reloj del periferico USART2

	/*
	 * Configurar los parametros de la comunicación serial
	*/

	USART2->CR1 = 0; //sobremuestreo 16; Usart disable; 1 bits start, 8 bits data; Idle Line; paridad off; paridad seleccion off; interrupt off; flag tx inhibet;

	/**
	 * FCK = 16Mhz
	 * BAUD = 115200
	 *
	 * USARTDIV = 16Mhz/(16*115200) = 8.681  Fclk/(Oversampling * baudRate)
	 * FRACTION = 4bits
	 * MANTISA = 12bits = 0x8
	 *
	 * fraction = 0.681 * 16(oversampling) = 10.896 -> 11 (redondeando) -> 0xB
	 */
	 USART2->BRR = 0x8U<<4 | 0xBU; //baudRate para 115200

	 USART2->CR1 |= USART_CR1_TE | USART_CR1_RE; //Habilitando transimision y recepción USART

	 USART2->CR1 |= USART_CR1_UE; //habilitar USART2

	 return;
}

void USART2_GPIO_Init(void){
	RCC -> AHB1ENR |= GPIOX_CLOCK(USART2_TX);
	//PA2 -> TX
	GPIOX_MODER(MODE_ALTER, USART2_TX);   	//pin PA2 modo funcion alternativa
	GPIOX_OSPEEDR(MODE_SPD_VHIGH,USART2_TX); //pin alta velocidad
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL2); //Limpiar los bits de funcion alternativa
	//GPIOA->AFR[0] |= (0x7U << 8U); //PA2 modo funcion alternativa para usarlo como USART2_TX (ver datasheet)
	GPIOA->MODER |= 0x7U << 8; //PA2 modo funcion alternativa para usarlo como USART2_TX (ver datasheet)

	//PA3 -> RX
	GPIOX_MODER(MODE_ALTER, USART2_RX);   	//pin PA2 modo funcion alternativa
	GPIOX_OSPEEDR(MODE_SPD_VHIGH,USART2_RX); //pin alta velocidad
	GPIOA->AFR[0] &= ~(GPIO_AFRL_AFRL3); //Limpiar los bits de funcion alternativa
	//GPIOA->AFR[0] |= (0x7U << 12U); //PA2 modo funcion alternativa para usarlo como USART2_RX (ver datasheet)
	//GPIOX_AFR(7U,USART2_RX);
	GPIOA->MODER |= 0x7U << 12; //PA2 modo funcion alternativa para usarlo como USART2_RX (ver datasheet)
	return;
}





